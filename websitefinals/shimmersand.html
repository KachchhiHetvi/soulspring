<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>This is Sand Simulation</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      background-color: #121212;
      font-family: Arial, sans-serif;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      height: 100vh;
    }
    
    #header {
      background-color: #000;
      color: #fff;
      padding: 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      z-index: 5;
    }
    
    h1 {
      font-size: 1.5rem;
      margin: 0;
    }
    
    #canvas-container {
      flex-grow: 1;
      position: relative;
    }
    
    canvas {
      display: block;
      background-color: #000;
    }
    
    /* MODIFIED: Vertical color palette on the left side */
    #controls {
      position: absolute;
      top: 50%;
      left: 20px;
      transform: translateY(-50%);
      display: flex;
      flex-direction: column;
      background-color: rgba(0, 0, 0, 0.7);
      border-radius: 12px;
      padding: 10px;
      z-index: 10;
    }
    
    .color-button {
      width: 30px;
      height: 30px;
      border-radius: 50%;
      border: 2px solid #fff;
      margin: 5px 0;
      cursor: pointer;
      transition: transform 0.2s;
    }
    
    .color-button:hover {
      transform: scale(1.2);
    }
    
    .color-button.active {
      box-shadow: 0 0 12px 2px white;
    }
    
    /* MODIFIED: Bottom control panel for brush size and clear button */
    #bottom-controls {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      background-color: rgba(0, 0, 0, 0.7);
      border-radius: 12px;
      padding: 10px;
      z-index: 10;
    }
    
    #size-control {
      display: flex;
      align-items: center;
    }
    
    #size-slider {
      width: 100px;
      margin: 0 10px;
      cursor: pointer;
    }
    
    #clear-button, #save-button {
      margin-left: 20px;
      color: white;
      border: none;
      padding: 5px 15px;
      border-radius: 15px;
      cursor: pointer;
      font-weight: bold;
    }
    
    #clear-button {
      background-color: #f44336;
    }
    
    #clear-button:hover {
      background-color: #d32f2f;
    }
    
    #save-button {
      background-color: #4CAF50;
    }
    
    #save-button:hover {
      background-color: #388E3C;
    }
    
    span {
      color: white;
    }
    
    #info {
      cursor: pointer;
      margin-right: 10px;
      font-size: 1.5rem;
    }
    
    #info-panel {
      position: fixed;
      top: 60px;
      left: 0;
      bottom: 0;
      width: 250px;
      background-color: rgba(0, 0, 0, 0.85);
      color: white;
      padding: 20px;
      overflow-y: auto;
      z-index: 100;
      border-right: 1px solid #333;
      transform: translateX(-100%);
      transition: transform 0.3s ease;
    }
    
    #info-panel.visible {
      transform: translateX(0);
    }
    
    #info-panel h2 {
      margin-bottom: 15px;
      border-bottom: 1px solid #444;
      padding-bottom: 10px;
    }
    
    #info-panel p {
      margin-bottom: 10px;
      line-height: 1.5;
    }
    
    #close-info {
      position: absolute;
      top: 10px;
      right: 10px;
      background: none;
      border: none;
      color: white;
      font-size: 1.2rem;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="header">
    <h1>This is Sand</h1>
    <div id="info">ⓘ</div>
  </div>
  
  <div id="canvas-container">
    <canvas id="sandCanvas"></canvas>
    
    <!-- MODIFIED: Vertical color palette on the left -->
    <div id="controls">
      <!-- Color palette will be generated by JS -->
    </div>
    
    <!-- MODIFIED: Bottom control panel with save button added -->
    <div id="bottom-controls">
      <div id="size-control">
        <span>Size:</span>
        <input type="range" id="size-slider" min="1" max="20" value="4">
      </div>
      <button id="save-button">Save</button>
      <button id="clear-button">Clear</button>
    </div>
  </div>
  
  <div id="info-panel">
    <button id="close-info">✕</button>
    <h2>How to Play with Sand</h2>
    <p>Click and drag your mouse or finger to drop sand. The sand will fall and interact with other particles, creating beautiful patterns.</p>
    <p>Choose different colors from the palette on the left side of the screen.</p>
    <p>Adjust the brush size using the slider at the bottom for different effects.</p>
    <p>Physics properties differ slightly between colors, try them all!</p>
    <p>Click "Save" to download your creation as an image.</p>
    <p>Click "Clear" to start over with a blank canvas.</p>
  </div>

  <script>
    // Initialize the sand simulation
    document.addEventListener('DOMContentLoaded', () => {
      // Canvas setup
      const canvas = document.getElementById('sandCanvas');
      const ctx = canvas.getContext('2d', { alpha: false });
      
      // Grid of pixels to track sand particles - Initialize grid first
      let grid = [];
      const cellSize = 1; // Each grid cell is 1px
      
      // Make canvas fill the container
      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight - 50; // Account for header
        
        // Now grid is defined so we can safely call createGrid
        createGrid();
      }
      
      // Function to create grid
      function createGrid() {
        const gridWidth = Math.ceil(canvas.width / cellSize);
        const gridHeight = Math.ceil(canvas.height / cellSize);
        
        grid = new Array(gridHeight);
        for (let y = 0; y < gridHeight; y++) {
          grid[y] = new Array(gridWidth).fill(null);
        }
        
        // Clear the canvas
        ctx.fillStyle = 'black';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }
      
      window.addEventListener('resize', resizeCanvas);
      resizeCanvas(); // This will also call createGrid() for initial setup
      
      // Sand properties
      let brushSize = 4;
      let isPouring = false;
      let currentColorIndex = 0;
      
      // Colors - these correspond to different types of sand
      // SPEED INCREASE: Reduced inertia values to make particles move faster
      const colors = [
        { hex: '#f4a261', r: 244, g: 162, b: 97, inertia: 0.05 },  // orange sand
        { hex: '#e76f51', r: 231, g: 111, b: 81, inertia: 0.07 },   // coral
        { hex: '#e9c46a', r: 233, g: 196, b: 106, inertia: 0.04 }, // yellow sand
        { hex: '#2a9d8f', r: 42, g: 157, b: 143, inertia: 0.03 },   // teal
        { hex: '#264653', r: 38, g: 70, b: 83, inertia: 0.08 },    // dark blue
        { hex: '#4cc9f0', r: 76, g: 201, b: 240, inertia: 0.02 },  // light blue
        { hex: '#f72585', r: 247, g: 37, b: 133, inertia: 0.06 },  // pink
        { hex: '#7209b7', r: 114, g: 9, b: 183, inertia: 0.07 },   // purple
        { hex: '#ffffff', r: 255, g: 255, b: 255, inertia: 0.02 }, // white
        { hex: '#8d99ae', r: 141, g: 153, b: 174, inertia: 0.09 }   // slate gray
      ];
      
      // MODIFIED: Generate color palette buttons vertically
      const controlsDiv = document.getElementById('controls');
      colors.forEach((color, index) => {
        const button = document.createElement('div');
        button.className = 'color-button' + (index === 0 ? ' active' : '');
        button.style.backgroundColor = color.hex;
        button.addEventListener('click', () => {
          document.querySelectorAll('.color-button').forEach(btn => btn.classList.remove('active'));
          button.classList.add('active');
          currentColorIndex = index;
        });
        controlsDiv.appendChild(button);
      });
      
      // Event listeners for pouring sand
      canvas.addEventListener('mousedown', (e) => {
        isPouring = true;
        pourSand(e);
      });
      
      canvas.addEventListener('mousemove', (e) => {
        if (isPouring) {
          pourSand(e);
        }
      });
      
      canvas.addEventListener('mouseup', () => {
        isPouring = false;
      });
      
      canvas.addEventListener('mouseleave', () => {
        isPouring = false;
      });
      
      // Touch events for mobile
      canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        isPouring = true;
        pourSand(e.touches[0]);
      });
      
      canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        if (isPouring) {
          pourSand(e.touches[0]);
        }
      });
      
      canvas.addEventListener('touchend', () => {
        isPouring = false;
      });
      
      // Pour sand at a specific location
      function pourSand(e) {
        const rect = canvas.getBoundingClientRect();
        const x = Math.floor((e.clientX - rect.left) / cellSize);
        const y = Math.floor((e.clientY - rect.top) / cellSize);
        
        // Add sand in a circle around the pointer
        for (let dy = -brushSize; dy <= brushSize; dy++) {
          for (let dx = -brushSize; dx <= brushSize; dx++) {
            if (dx*dx + dy*dy <= brushSize*brushSize) {
              const nx = x + dx;
              const ny = y + dy;
              
              if (nx >= 0 && nx < grid[0].length && ny >= 0 && ny < grid.length) {
                if (Math.random() > 0.5) { // Randomize for natural look
                  grid[ny][nx] = { ...colors[currentColorIndex] };
                  
                  // Draw the pixel immediately
                  const color = colors[currentColorIndex];
                  ctx.fillStyle = `rgb(${color.r},${color.g},${color.b})`;
                  ctx.fillRect(nx * cellSize, ny * cellSize, cellSize, cellSize);
                }
              }
            }
          }
        }
      }
      
      // Update the size of the sand brush
      document.getElementById('size-slider').addEventListener('input', (e) => {
        brushSize = parseInt(e.target.value);
      });
      
      // NEW: Save functionality - Save canvas as an image
      document.getElementById('save-button').addEventListener('click', () => {
        // Create a temporary link element
        const link = document.createElement('a');
        
        // Set download attributes
        link.download = 'sand-creation.png';
        
        // Convert canvas to data URL
        link.href = canvas.toDataURL('image/png');
        
        // Append to body and trigger click
        document.body.appendChild(link);
        link.click();
        
        // Clean up
        document.body.removeChild(link);
        
        // Visual feedback that save was triggered
        const saveButton = document.getElementById('save-button');
        const originalText = saveButton.textContent;
        saveButton.textContent = 'Saved!';
        saveButton.style.backgroundColor = '#388E3C';
        
        // Reset button text after 1 second
        setTimeout(() => {
          saveButton.textContent = originalText;
          saveButton.style.backgroundColor = '#4CAF50';
        }, 1000);
      });
      
      // Clear button functionality
      document.getElementById('clear-button').addEventListener('click', () => {
        createGrid();
      });
      
      // Info panel controls
      document.getElementById('info').addEventListener('click', () => {
        document.getElementById('info-panel').classList.add('visible');
      });
      
      document.getElementById('close-info').addEventListener('click', () => {
        document.getElementById('info-panel').classList.remove('visible');
      });
      
      // Main simulation loop
      function update() {
        // SPEED INCREASE: Process more updates per frame (4 iterations instead of 2)
        // We run the simulation multiple times per frame to make sand move faster
        for (let iteration = 0; iteration < 4; iteration++) {
          // We start from the bottom for gravity to work naturally
          for (let y = grid.length - 2; y >= 0; y--) {
            for (let x = 0; x < grid[0].length; x++) {
              const cell = grid[y][x];
              if (cell) {
                // Skip if this sand particle cannot move this frame (based on inertia)
                if (Math.random() > cell.inertia) {
                  moveSand(x, y);
                }
              }
            }
          }
        }
        
        // Redraw the grid (could be optimized to only draw changed pixels)
        for (let y = 0; y < grid.length; y++) {
          for (let x = 0; x < grid[0].length; x++) {
            const cell = grid[y][x];
            if (cell) {
              ctx.fillStyle = `rgb(${cell.r},${cell.g},${cell.b})`;
              ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
            }
          }
        }
        
        requestAnimationFrame(update);
      }
      
      // Rule for moving sand
      function moveSand(x, y) {
        const below = y + 1;
        
        // If there's space directly below, fall down
        if (below < grid.length && !grid[below][x]) {
          grid[below][x] = grid[y][x];
          grid[y][x] = null;
          
          // Clear the old position
          ctx.fillStyle = 'black';
          ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
        } 
        // Try to slide down-left or down-right (50/50 chance for direction)
        else {
          const direction = Math.random() > 0.5 ? 1 : -1;
          const leftOrRight = x + direction;
          
          // First try the random direction
          if (leftOrRight >= 0 && leftOrRight < grid[0].length && 
              below < grid.length && !grid[below][leftOrRight]) {
            grid[below][leftOrRight] = grid[y][x];
            grid[y][x] = null;
            
            // Clear the old position
            ctx.fillStyle = 'black';
            ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
          } 
          // If that fails, try the other direction
          else {
            const otherDirection = x - direction;
            if (otherDirection >= 0 && otherDirection < grid[0].length && 
                below < grid.length && !grid[below][otherDirection]) {
              grid[below][otherDirection] = grid[y][x];
              grid[y][x] = null;
              
              // Clear the old position
              ctx.fillStyle = 'black';
              ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
            }
          }
        }
      }
      
      // Start the simulation
      update();
    });
  </script>
</body>
</html>